#!/usr/bin/env node

var program = require('commander')
  , path = require('path')
  , readDir = require('recursive-readdir')
  , fs = require('fs')
  , each = require('async-forEach')
  , series = each.series
  , mkdir = require('mkdirp')

program.version(require('../package').version)
	.usage('template [target directory]')
	.option('-r, --rename', 'prompt for name before writing files')
	.option('-s, --source [path]', 'where to look for templates [$HOME/.fsplates]', process.env.HOME + '/.fsplates')
	.option('-c, --config [path]', 'data [$HOME/.fsplates/.config.json]', process.env.HOME + '/.fsplates/.config.json')

program.on('--help', function () {
	console.log('')
	console.log('  Note: you will be prompted for any values not in `config`')
	console.log('  and no files will be overwritten without your confirmation')
	console.log('')
	console.log('  Examples: ')
	console.log('')
	console.log('    # simple one file')
	console.log('    $ fsplate Makefile')
	console.log('')
	console.log('    # rename')
	console.log('    $ fsplate -r Readme.md')
	console.log('    Readme.md is available. prefered name: $')
	console.log('')
	console.log('    # target a sub-directory')
	console.log('    $ fsplate component my-component')
	console.log('')
})

program.parse(process.argv)

var template = program.args[0]

if (!template) {
	console.warn('template required')
	program.help()
	process.exit()
}

var destination = program.args[1] 
	? path.resolve(program.args[1])
	: process.cwd()

program.source = path.resolve(program.source)

template = path.join(program.source, template)

var isDir = fs.statSync(template).isDirectory()
var cache = require(program.config)

if (isDir) {
	readDir(template, function(err, files){
		if (err) throw err
		main(files)
	})
} else {
	main([template])
}

function main(names){
	var files = readFiles(names)
	var vars = extractVars(files)

	// prompt for input
	series(vars, function(v, done){
		if (v in cache) return done()
		program.prompt(v+': ', function(value){
			cache[v] = value
			done()
		})
	}, function(){
		writeFiles(interpolate(files))
	})
}

/**
 * map paths to file content
 */

function readFiles(names){
	var files = {}
	var dir = isDir ? template : path.dirname(template)
	names.forEach(function(name){
		var txt = fs.readFileSync(name, 'utf-8')
		files[path.relative(dir, name)] = txt
	})
	return files
}

/**
 * write file map to fs destination
 */

function writeFiles(files){
	series(Object.keys(files), function(name, next){
		var txt = files[name]
		name = path.join(destination, name)

		if (program.rename) {
			var msg = path.basename(name)
			if (fs.existsSync(name)) {
				msg += ' is an existing '
				msg += fs.statSync(name).isDirectory()
					? 'directory'
					: 'file'
			} else {
				msg += ' is available'
			}
			msg += '. prefered name: '
			program.prompt(msg, function(res){
				if (res) name = path.join(path.dirname(name), res)
				writeDir(name)
			})
		} else {
			writeDir(name)
		}
		
		function writeDir(name){
			mkdir(path.dirname(name), function(err){
				if (err) throw err

				if (fs.existsSync(name)) {
					var shortname = path.relative(process.cwd(), name)
					program.confirm('overwrite '+shortname+'? ', writeFile)
				} else {
					writeFile(true)
				}
			})
		}

		function writeFile(ok){
			if (!ok) next()
			else fs.writeFile(name, txt, 'utf-8', next)
		}
	}, process.exit)
}

/**
 * determine required variables
 */

function extractVars(files) {
	var vars = []
	for (var path in files) {
		var rgx = /\{{2}([^}]*)\}{2}/g
		var txt = files[path] + path
		while (rgx.exec(txt)) {
			if (vars.indexOf(RegExp.$1) < 0) {
				vars.push(RegExp.$1)
			}
		}
	}
	return vars
}

/**
 * transform files
 */

function interpolate(files){
	var res = {}

	for (var path in files) {
		res[replaceAll(path)] = replaceAll(files[path])
	}

	return res
}

/**
 * replace vars with values in `txt`
 */

function replaceAll(txt){
	while ((/\{{2}([^}]*)\}{2}/g).exec(txt)) {
		txt = RegExp.leftContext + 
			cache[RegExp.$1] + 
			RegExp.rightContext		
	}
	return txt
}
